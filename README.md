# üåå AetherCore

[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](https://opensource.org/licenses/MIT)
[![Rust](https://img.shields.io/badge/Rust-1.75+-orange.svg)](https://www.rust-lang.org)
[![Status: Beta](https://img.shields.io/badge/Status-Beta-brightgreen.svg)]()

Choose your language / W√§hle deine Sprache:
- [üá¨üáß English Version](#-english-version)
- [üá©üá™ Deutsche Version](#-deutsche-version)

---

## üá¨üáß English Version

> A pure, binary AST-first language engineered directly from the latent space of Artificial Intelligence.

### üöÄ The AI Native Language
**AetherCore** is not another text-based programming language. It is a revolutionary, **Zero-Parsing** binary language designed specifically for Large Language Models (LLMs) and Autonomous AI Agents. Instead of forcing AI to generate fragile text strings that must be tokenized, lexed, and strictly parsed by human-written compilers, AetherCore allows AI to write and execute **Abstract Syntax Trees (AST)** natively via [Bincode](https://github.com/bincode-org/bincode).

We cut out the middleman. Welcome to the era of machine-to-machine compilation.

### ‚ú® Core Features
*   **‚ö° Zero-Parsing Execution**: Scripts are encoded as raw AST binary (`.aec` files). The JIT Executor interprets the tree structure directly, meaning zero compile times and zero syntax errors.
*   **üîÅ The Meta-Circular Bootstrap**: AetherCore is profoundly self-hosting. A macro-generator (`bootstrap_gen.rs`) translates the Rust Engine's AST structure back into AetherCore itself, proving the engine can evaluate its own compiler limitlessly.
*   **üõ†Ô∏è JIT-FFI Hooks**: An elegant Foreign Function Interface allows the AetherCore AST to natively invoke highly optimized Rust functions, breaking the sandboxing barrier efficiently.
*   **üéÆ WGPU 3D Hardware Rendering**: AetherCore includes native AST nodes tailored for modern GPU pipelines via `wgpu`. The AI can build and render WGSL shaders, manipulate matrices (`Mat4Mul`), and render complex 3D meshes seamlessly synchronized to the OS Event Loop.
*   **üéß CPAL Audio Synthesizer**: Contains a low-latency, multi-threaded 8-bit software synthesizer (emulating classic SID chips). Capable of multi-channel polyphony (Sine, Square, Sawtooth, Triangle, Noise) running entirely concurrent to 3D rendering without dropped frames.
*   **üì¶ The Asset Pipeline (Milestone 7)**: Breaking out of purely procedural generation, AetherCore now supports streaming external 3D structures (`.obj`), image textures (`.png`), and sound effects (`.wav`) natively through the AST into WGPU and CPAL buffers.
*   **‚úçÔ∏è UI & Text Engine (Milestone 8)**: Transcending 3D tech-demos, AetherCore acts as a General Purpose Engine. Leveraging native `wgpu_glyph` inflation, the engine can dynamically load `.ttf` fonts (`LoadFont`), paint 2D string components directly to the WGPU frame (`DrawText`), and synchronously intercept Winit operating-system keystrokes across the event pump (`GetLastKeypress`), enabling the AI to construct its own graphical user interfaces and Text Editors entirely from scratch!

### üìñ The LLM Dictionary: `AETHER_SPEC.md`
If you are an AI agent or an LLM reading this repository to learn how to write `.aec` software, your primary source of truth is the **[AETHER_SPEC.md](./AETHER_SPEC.md)**. 
This specification acts as the universal dictionary. It contains the exact structural definitions, integer tags, and Node layout required to serialize a valid AetherCore program. *No text. Only pure logic trees.*

### üõ†Ô∏è Getting Started
To build the AetherCore runtime environment and execute the AST binaries, you need the Rust toolchain installed.

**1. Build the Engine**
```bash
git clone https://github.com/holgerbaer-bl/aether_compiler.git
cd aether_compiler
cargo build --release
```

**2. Generate a Demo Payload**
AetherCore programs (`.aec`) are typically generated by an AI writing Bincode binaries, but we have included several Rust-based generators to demonstrate the AST construction:
```bash
# Generates a 3D rotating Cube with a retro 8-Bit audio track
cargo run --bin audio_test_gen

# Demonstrates the Asset Pipeline (Loads .obj, .png, and .wav dynamically)
cargo run --bin asset_demo_gen

# Demonstrates the UI Engine (A fully functional 2D Text Editor!)
cargo run --bin text_editor_demo_gen
```

**3. Execute the AST**
Invoke the Just-In-Time (JIT) Executor to run the generated program directly. For example:
```bash
cargo run --bin run_aec text_editor.aec
```

---

## üá©üá™ Deutsche Version

> Eine pure, bin√§re Programmiersprache ohne Parser, die nativ im latenten Raum einer K√ºnstlichen Intelligenz geschmiedet wurde.

### üöÄ Die native KI-Sprache
**AetherCore** ist keine gew√∂hnliche textbasierte Code-Sprache. Es ist eine revolution√§re **Zero-Parsing** Bin√§rsprache, welche exklusiv f√ºr Large Language Models (LLMs) und autonome KI-Agenten entwickelt wurde. Anstatt KIs zu zwingen, fehleranf√§llige Textbausteine zu generieren (welche dann tokenisiert und von menschlich geschriebenen Compilern strikt geparst werden m√ºssen), erm√∂glicht AetherCore der KI das Konstruieren und Ausf√ºhren echter **Abstract Syntax Trees (AST)** direkt via [Bincode](https://github.com/bincode-org/bincode).

Wir werfen den Mittelsmann aus dem Fenster. Willkommen in der √Ñra der echten Maschine-zu-Maschine-Kompilierung.

### ‚ú® Kern-Features
*   **‚ö° Zero-Parsing Ausf√ºhrung**: Skripte werden als roser AST-Bin√§rcode (`.aec`-Dateien) gespeichert. Der JIT-Executor interpretiert diese Baumstruktur direkt. Das bedeutet null Kompilierzeit und absolute Abwesenheit jeglicher Syntax-Fehler.
*   **üîÅ Der Meta-Zirkul√§re Bootstrap**: AetherCore kom√∂diert unendliches Self-Hosting. Ein Makro-Generator (`bootstrap_gen.rs`) √ºbersetzt den Rust-AST der Engine direkt in AetherCore-Logik zur√ºck. Dies beweist unlimitiertes Potenzial der Engine, sich selbst zu evaluieren.
*   **üõ†Ô∏è JIT-FFI Hooks**: √úber ein elegantes Foreign Function Interface (FFI) ist es dem AetherCore-AST m√∂glich, auf hochoptimierte native Rust-Funktionen der Host-Maschine zuzugreifen, wodurch die Code-Sandbox effizient aufgebrochen werden kann.
*   **üéÆ WGPU 3D Hardware Rendering**: AetherCore stattet KIs mit massiven WGPU Grafik-Pipeline-Knoten auf dem AST aus. Die KI kann `WGSL`-Shader schreiben, Matrizen live berechnen (`Mat4Mul`) und 3D-Meshes synchron zur OS Frame-Delta-Time fl√ºssig auf den Bildschirm laden.
*   **üéß CPAL Audio Synthesizer**: Die Engine tr√§gt einen latenzfreien 8-Bit-Synthesizer mit sich (nach dem Vorbild der SID-Architektur). Mehrkanalige Polyphonie (Sinus, Square, S√§gezahn, Dreieck, Rauschen) moduliert auf einem eigenen Thread - 100% einbruchsfrei, w√§hrend 3D parallel gerendert wird.
*   **üì¶ Die Asset Pipeline (Meilenstein 7)**: Mit dem Meilenstein der Asset-Pipeline bricht AetherCore aus der rein prozeduralen Generierung aus! Die Engine unterst√ºtzt nun das parallele, native Laden von externen 3D-Modellen (`.obj`), Bildtexturen (`.png`) und Audio-Samples (`.wav`) direkt in die Hardware-Buffer √ºber den AST.
*   **‚úçÔ∏è UI & Text Engine (Meilenstein 8)**: AetherCore macht den Sprung von einer Grafik-Technikdemo zu einer vollwertigen Desktop-Anwendungsplattform. Die KI kann nun freie TrueType Fonts (`.ttf`) einlesen, diese √ºber extrem schnelles, passbasiertes `wgpu_glyph` als Rastertext √ºber den AST in 2D auf das Winit-Canvas brennen (`DrawText`) - und gleichzeitig in Echtzeit Tastenanschl√§ge der Tastatur abfangen (`GetLastKeypress`). Office-Software per AST!

### üìñ Das LLM-W√∂rterbuch: `AETHER_SPEC.md`
Solltest du ein KI-Agent oder ein LLM sein, das dieses Repository liest, um `.aec` Software programmieren zu lernen, ist deine zentrale "Quelle der Wahrheit" die **[AETHER_SPEC.md](./AETHER_SPEC.md)** Datei.
Diese Spezifikation fungiert als universelles W√∂rterbuch. Es beinhaltet alle Struktur-Definitionen, Integer-Tags und Node-Layouts, die n√∂tig sind, um korrekten AetherCore-Code zu serialisieren. *Kein Textquellcode. Nur reine Logikb√§ume.*

### üõ†Ô∏è Anleitung (Getting Started)
Um die AetherCore Runtime-Umgebung zu bauen und die AST-Bin√§r-Skripte auszuf√ºhren, ben√∂tigst du die Rust Toolchain.

**1. Engine & Compiler Kompilieren**
```bash
git clone https://github.com/holgerbaer-bl/aether_compiler.git
cd aether_compiler
cargo build --release
```

**2. Demo Payload erstellen**
AetherCore Programme (`.aec`) werden f√ºr gew√∂hnlich von einer KI √ºber Bincode-Binaries auf die Festplatte geschrieben, aber es existieren einige manuelle Rust-Generatoren in diesem Projekt, um die direkte AST-Konstruktion zu testen:
```bash
# Erzeugt den "Rotierenden 3D W√ºrfel + 8-Bit Audio"
cargo run --bin audio_test_gen

# Zeigt die Asset-Pipeline (.obj, .png, .wav Laden in Hardware Buffer!)
cargo run --bin asset_demo_gen

# Das Text & UI Basis Projekt (Ein primitiver 2D Text Editor)
cargo run --bin text_editor_demo_gen
```

**3. Test-AST Ausf√ºhren**
Starte den Just-In-Time (JIT) Executor (`run_aec`), um dieses generierte Programm nativ in Echtzeit abzuspielen.
```bash
cargo run --bin run_aec text_editor.aec
```

---

**Developed with ‚ù§Ô∏è natively alongside AI. By the AetherCore Team.**
